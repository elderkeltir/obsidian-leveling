<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>&lt;Obsidian&gt;TBC Leveling Finder</title>

  <!-- Tabulator (table UI: sorting, filtering, etc.) -->
  <link href="https://unpkg.com/tabulator-tables@6.2.5/dist/css/tabulator.min.css" rel="stylesheet">

  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: #0b1020;
      color: #e7eaf3;
    }

    header {
      padding: 18px 18px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent);
    }
    h1 { margin: 0 0 6px; font-size: 18px; font-weight: 700; }
    .sub { opacity: .8; font-size: 13px; }

    .wrap { padding: 14px 18px 24px; max-width: 1200px; margin: 0 auto; }

    .panel {
      padding: 12px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      background: rgba(255,255,255,.04);
      margin-bottom: 12px;
    }

    /* Responsive layout that won't overlap:
       auto-fit creates as many columns as fit, min width 260px, otherwise stacks */
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
      align-items: start;
    }

    .control {
      padding: 10px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      background: rgba(0,0,0,.18);
    }

    label {
      display: block;
      font-size: 12px;
      opacity: .85;
      margin: 0 0 8px;
    }

    input[type="text"], input[type="time"] {
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: #e7eaf3;
      outline: none;
    }

    .checks {
      display: flex;
      flex-wrap: wrap;
      gap: 10px 14px;
      align-items: center;
    }
    .checks .item {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      user-select: none;
      white-space: nowrap;
    }

    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 10px;
    }

    button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: #e7eaf3;
      cursor: pointer;
    }
    button:hover { background: rgba(255,255,255,.10); }

    .hint { font-size: 12px; opacity: .75; }
    .error { color: #ffb4b4; }
    .ok { color: #b7ffcf; }

    /* Table container height: fill most of viewport, no weird whitespace */
    #table {
      height: calc(100vh - 290px);
      min-height: 420px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(255,255,255,.02);
    }

    /* Make Tabulator match dark UI a bit */
    .tabulator { background: transparent; }
    .tabulator .tabulator-header {
      background: rgba(255,255,255,.04);
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .tabulator .tabulator-row {
      background: transparent;
      border-bottom: 1px solid rgba(255,255,255,.06);
    }
    .tabulator .tabulator-row:hover { background: rgba(255,255,255,.05); }
    .tabulator .tabulator-cell { border-right: 1px solid rgba(255,255,255,.05); }

    @media (max-width: 520px) {
      #table { height: calc(100vh - 330px); }
    }

    #table { background: rgba(0,0,0,.12); }

.tabulator{
  background: transparent !important;
  color: #e7eaf3 !important;
  border: 1px solid rgba(255,255,255,.10) !important;
}

.tabulator .tabulator-header{
  background: rgba(255,255,255,.05) !important;
  border-bottom: 1px solid rgba(255,255,255,.10) !important;
  color: #e7eaf3 !important;
}

.tabulator .tabulator-header .tabulator-col{
  background: transparent !important;
  border-right: 1px solid rgba(255,255,255,.08) !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content{
  padding: 10px 10px !important;
}

.tabulator .tabulator-tableholder{
  background: transparent !important;
}

.tabulator .tabulator-row{
  background: rgba(0,0,0,.12) !important;
  border-bottom: 1px solid rgba(255,255,255,.06) !important;
}

.tabulator .tabulator-row:nth-child(even){
  background: rgba(255,255,255,.03) !important;
}

.tabulator .tabulator-row:hover{
  background: rgba(255,255,255,.06) !important;
}

.tabulator .tabulator-cell{
  border-right: 1px solid rgba(255,255,255,.06) !important;
  color: #e7eaf3 !important;
}

/* Optional: make the sort arrows visible on dark */
.tabulator .tabulator-col.tabulator-sortable .tabulator-col-title-holder{
  color: #e7eaf3 !important;
}
.tabulator .tabulator-col .tabulator-arrow{
  border-bottom-color: rgba(231,234,243,.85) !important;
  border-top-color: rgba(231,234,243,.85) !important;
}

/* Optional: selected row */
.tabulator .tabulator-row.tabulator-selected{
  background: rgba(120,160,255,.18) !important;
}
  </style>
</head>

<body>
  <header>
    <h1>TBC Leveling Finder</h1>
    <div class="sub">Sortable + filterable table from Google Forms responses (CSV).</div>
  </header>

  <div class="wrap">
    <div class="panel">
      <div class="controls">
        <div class="control">
          <label>Search (name / roles / leveling)</label>
          <input id="search" type="text" placeholder="e.g. Kethra, Tank, Questing..." />
          <div class="hint" style="margin-top:8px;">
            Loads automatically on page open. Refresh the page to fetch latest responses.
          </div>
        </div>

        <div class="control">
          <label>Needed time window (server time)</label>
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
            <div>
              <label style="margin:0 0 6px; opacity:.75;">Need from</label>
              <input id="needStart" type="time" value="21:00" />
            </div>
            <div>
              <label style="margin:0 0 6px; opacity:.75;">Need until</label>
              <input id="needEnd" type="time" value="23:00" />
            </div>
          </div>
          <div class="checks" style="margin-top:10px;">
            <span class="item"><input type="checkbox" id="partialOverlap" /> Any overlap (else must fully cover)</span>
          </div>
        </div>

        <div class="control">
          <label>Leveling</label>
          <div class="checks">
            <span class="item"><input type="checkbox" id="wantDungeon" checked /> Dungeon</span>
            <span class="item"><input type="checkbox" id="wantQuesting" checked /> Questing</span>
          </div>

          <label style="margin-top:12px;">Roles (any checked)</label>
          <div class="checks">
            <span class="item"><input type="checkbox" id="needTank" /> Tank</span>
            <span class="item"><input type="checkbox" id="needHeal" /> Heal</span>
            <span class="item"><input type="checkbox" id="needDps" /> DPS</span>
          </div>
        </div>
      </div>

      <div class="actions">
        <button id="clearBtn">Clear filters</button>
        <span id="status" class="hint"></span>
      </div>
    </div>

    <div id="table"></div>
  </div>

  <!-- CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- Tabulator -->
  <script src="https://unpkg.com/tabulator-tables@6.2.5/dist/js/tabulator.min.js"></script>

  <script>
    // =========================
    // 1) PUT YOUR CSV LINK HERE
    // =========================
    // Google Sheets: File → Share → Publish to web → select sheet tab → CSV → Publish → copy URL (output=csv)
    const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQvkAp0aU1DbyCG2dJiZzSBbUAIN6PhivKltGkISOZUmB_LO8E1MfddYJ0I_oOtksNZJGjx8Dt2_k9F/pub?gid=1871468470&single=true&output=csv";

    // ---- Helpers ----
    function setStatus(msg, cls) {
      const el = document.getElementById("status");
      el.textContent = msg || "";
      el.className = "hint " + (cls || "");
    }

    function timeToMinutes(t) {
      if (!t) return null;
      // Accept "HH:MM" or "HH:MM:SS"
      const parts = String(t).trim().split(":").map(x => parseInt(x, 10));
      if (parts.length < 2 || Number.isNaN(parts[0]) || Number.isNaN(parts[1])) return null;
      return parts[0] * 60 + parts[1];
    }

    function findCol(headers, mustIncludeLowercaseArray) {
      // Find a header that contains all required substrings (case-insensitive)
      const req = mustIncludeLowercaseArray.map(s => s.toLowerCase());
      for (const h of headers) {
        const hl = String(h).toLowerCase();
        let ok = true;
        for (const r of req) {
          if (!hl.includes(r)) { ok = false; break; }
        }
        if (ok) return h;
      }
      return null;
    }

    function normalizeRow(r, cols) {
      const leveling = (r[cols.leveling] || "").toString();
      const roles    = (r[cols.roles] || "").toString();

      const startMin = timeToMinutes(r[cols.start]);
      const endMin0  = timeToMinutes(r[cols.end]);

      // Adjust for after-midnight ranges: end < start => end + 24h
      let endMin = endMin0;
      if (startMin != null && endMin0 != null && endMin0 < startMin) endMin = endMin0 + 24 * 60;

      return {
        name: r[cols.name] || "",
        leveling,
        roles,
        start: r[cols.start] || "",
        end: r[cols.end] || "",
        startMin,
        endMin,

        hasDungeon: /Dungeon/i.test(leveling),
        hasQuesting: /Questing/i.test(leveling),

        roleTank: /Tank/i.test(roles),
        roleHeal: /Heal/i.test(roles),
        roleDps: /DPS/i.test(roles),
      };
    }

    // ---- Table ----
    const table = new Tabulator("#table", {
      height: "100%",
      layout: "fitColumns",
      placeholder: "Loading…",
      reactiveData: true,
      columns: [
        {title: "Name", field: "name", sorter: "string", widthGrow: 1.2},
        {title: "Leveling", field: "leveling", sorter: "string", widthGrow: 2},
        {title: "Roles", field: "roles", sorter: "string", widthGrow: 1.4},
        {title: "Start", field: "start", sorter: "string", hozAlign:"center", width: 110},
        {title: "End", field: "end", sorter: "string", hozAlign:"center", width: 110},
        {title: "Dungeon", field: "hasDungeon", sorter:"boolean", hozAlign:"center", width: 110, formatter:"tickCross"},
        {title: "Questing", field: "hasQuesting", sorter:"boolean", hozAlign:"center", width: 110, formatter:"tickCross"},
        {title: "Tank", field: "roleTank", sorter:"boolean", hozAlign:"center", width: 90, formatter:"tickCross"},
        {title: "Heal", field: "roleHeal", sorter:"boolean", hozAlign:"center", width: 90, formatter:"tickCross"},
        {title: "DPS", field: "roleDps", sorter:"boolean", hozAlign:"center", width: 90, formatter:"tickCross"},
      ],
    });

    // Custom filter function using UI state
    function applyFilters() {
      const q = document.getElementById("search").value.trim().toLowerCase();

      const wantDungeon = document.getElementById("wantDungeon").checked;
      const wantQuesting = document.getElementById("wantQuesting").checked;

      const needTank = document.getElementById("needTank").checked;
      const needHeal = document.getElementById("needHeal").checked;
      const needDps  = document.getElementById("needDps").checked;

      const partialOverlap = document.getElementById("partialOverlap").checked;

      const needStart = timeToMinutes(document.getElementById("needStart").value);
      const needEnd0  = timeToMinutes(document.getElementById("needEnd").value);

      // If user sets a window that crosses midnight (e.g. 23:00 → 01:00), treat end as next day.
      let needEnd = needEnd0;
      if (needStart != null && needEnd0 != null && needEnd0 < needStart) needEnd = needEnd0 + 24 * 60;

      table.setFilter(function(rowData) {
        // Text search
        if (q) {
          const hay = (rowData.name + " " + rowData.leveling + " " + rowData.roles).toLowerCase();
          if (!hay.includes(q)) return false;
        }

        // Leveling preferences
        const levelingOk = (wantDungeon && rowData.hasDungeon) || (wantQuesting && rowData.hasQuesting);
        if (!levelingOk) return false;

        // Roles: if any role checkbox checked, match ANY of them
        const anyRoleChecked = needTank || needHeal || needDps;
        if (anyRoleChecked) {
          const roleOk = (needTank && rowData.roleTank) || (needHeal && rowData.roleHeal) || (needDps && rowData.roleDps);
          if (!roleOk) return false;
        }

        // Time window
        if (needStart != null && needEnd != null && rowData.startMin != null && rowData.endMin != null) {
          if (partialOverlap) {
            // overlap: start < needEnd AND end > needStart
            if (!(rowData.startMin < needEnd && rowData.endMin > needStart)) return false;
          } else {
            // full cover: start <= needStart AND end >= needEnd
            if (!(rowData.startMin <= needStart && rowData.endMin >= needEnd)) return false;
          }
        }

        return true;
      });
    }

    function clearFilters() {
      document.getElementById("search").value = "";
      document.getElementById("wantDungeon").checked = true;
      document.getElementById("wantQuesting").checked = true;
      document.getElementById("needTank").checked = false;
      document.getElementById("needHeal").checked = false;
      document.getElementById("needDps").checked = false;
      document.getElementById("partialOverlap").checked = false;
      document.getElementById("needStart").value = "21:00";
      document.getElementById("needEnd").value = "23:00";
      applyFilters();
    }

    // Load CSV and populate table (auto on page load)
    async function loadCsvIntoTable() {
      if (!CSV_URL || CSV_URL.includes("PASTE_YOUR_PUBLISHED_CSV_URL_HERE")) {
        setStatus("Set CSV_URL inside index.html first.", "error");
        table.replaceData([]);
        table.updateOrAddData([], true);
        table.setPlaceholder("Set CSV_URL in index.html to load data.");
        return;
      }

      setStatus("Loading…", "");
      try {
        const res = await fetch(CSV_URL, { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);

        const csvText = await res.text();
        const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true });

        const raw = parsed.data || [];
        const headers = (parsed.meta && parsed.meta.fields) ? parsed.meta.fields : Object.keys(raw[0] || {});

        // Try to auto-detect columns by header text (robust vs typos like "Prefered")
        const cols = {
          name:     findCol(headers, ["character", "name"]) || findCol(headers, ["name"]),
          leveling: findCol(headers, ["leveling"]),
          roles:    findCol(headers, ["roles"]),
          start:    findCol(headers, ["start", "time"]),
          end:      findCol(headers, ["end", "time"]),
        };

        // Basic validation
        if (!cols.name || !cols.leveling || !cols.roles || !cols.start || !cols.end) {
          console.log("Detected headers:", headers);
          console.log("Detected cols:", cols);
          setStatus("Could not detect required columns. Check your Sheet headers.", "error");
          table.setPlaceholder("Column detection failed. Open DevTools console for details.");
          return;
        }

        const normalized = raw.map(r => normalizeRow(r, cols)).filter(r => r.name);

        table.setData(normalized);
        applyFilters();
        setStatus(`Loaded ${normalized.length} entries.`, "ok");
      } catch (e) {
        console.error(e);
        setStatus("Failed to load CSV. Check that the sheet is published as CSV and link is correct.", "error");
        table.setPlaceholder("Failed to load CSV.");
      }
    }

    // Wire UI
    document.getElementById("clearBtn").addEventListener("click", clearFilters);
    ["search","wantDungeon","wantQuesting","needTank","needHeal","needDps","partialOverlap","needStart","needEnd"]
      .forEach(id => document.getElementById(id).addEventListener("input", applyFilters));

    // Auto-load on open
    window.addEventListener("DOMContentLoaded", () => {
      loadCsvIntoTable();
    });
  </script>
</body>
</html>
